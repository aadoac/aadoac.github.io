<!doctype html>
<html>
  <head>
    <link rel="stylesheet" href="../css/style.css">
    <title>Strategy for Parameter Passing in Java</title>
  </head>
  <body>
    <div id="mainDiv">
      <h1>Strategy for Parameter Passing in Java</h1>
      <h2>Introduction</h2>
      <p>Java uses a pass-by-value strategy for parameter passing. This means that when a method is called with parameters, a temporary copy of each argument's value is created.</p>

      <h2>How It Works in Java</h2>
      <p>When a thread calls a method in Java, a new block is created in the stack memory with the local variables. Once the method ends, this block is removed from the stack.</p>
      <p>The following example will help us gain a better understanding. It is recommended to have some knowledge of how memory works in Java, and to understand the concepts of Stack memory and Heap memory.</p>

      <h2>Hands-on</h2>
      <p>In our example, we're going to build a small application to modify a person's last name. This application will also retain the old information; however, the old information will not be enabled. To do this, we will create a <span class="coding-font">Person</span> class with the following fields: name, last name, and a flag indicating whether this person is enabled.</p>
      <div class="github-code">
        <script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Faadoac%2FParameter-passing-java%2Fblob%2Fmain%2Fsrc%2Fmain%2Fjava%2Forg%2Famazed%2Fparameter%2Fpassing%2FPerson.java&style=a11y-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on"></script>
      </div>
        
      <p>To facilitate last name modification, we utilize the <span class="coding-font">PersonAction</span> class. This class provides two methods that illustrate the behavior of parameter passing in Java. The first method, <span class="coding-font">changeLastName</span>, updates the last name directly without cloning the <span class="coding-font">Person</span> object. The second method, <span class="coding-font">changeLastNameClone</span>, modifies the last name within a cloned instance of the original <span class="coding-font">Person</span> object.</p>
      <div class="github-code">
        <script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Faadoac%2FParameter-passing-java%2Fblob%2Fmain%2Fsrc%2Fmain%2Fjava%2Forg%2Famazed%2Fparameter%2Fpassing%2FPersonAction.java&style=a11y-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on"></script>
      </div>

      <p>In the first test, <span class="coding-font">test1</span>, a <span class="coding-font">Person</span> object is provided as an argument. Inside the <span class="coding-font">changeLastName</span> method, a new variable named <span class="coding-font">newPerson</span> is created, typically by assigning the value of the original <span class="coding-font">Person</span> object to it. The last name of <span class="coding-font">newPerson</span> is then modified. After this change, the test checks whether the modfication affected the original <span class="coding-font">Person</span> object. The result demonstrates that both the original <span class="coding-font">person</span> object and the <span class="coding-font">newPerson</span> object are actually referring to the same instance. As a result, changing the last name via <span class="coding-font">newPerson</span> also changes the last name of the original <span class="coding-font">person</span> object.</p>
      <p>This demonstrates that when new temporary local variables are created in the stack memory, they actually refer to the same objects located in heap memory, just as they did in the previous method. As a result, any changes made through one variable are reflected in the other, since both variables point to the same object.</p>

      <p>In the second test, <span class="coding-font">test2</span>, the <span class="coding-font">person</span> object is passed, and a new variable is created within the <span class="coding-font">changeLastNameClone</span> method. However, in this case, the object is cloned, meaning that a new copy of the object is created. The modifications are applied to the <span class="coding-font">newPerson</span> object, and as a result, the <span class="coding-font">person</span> object and the <span class="coding-font">newPerson</span> object are not the same.</p>
      <div class="github-code">
        <script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Faadoac%2FParameter-passing-java%2Fblob%2Fmain%2Fsrc%2Ftest%2Fjava%2Forg%2Famazed%2Fparameter%2Fpassing%2FPersonActionTest.java&style=a11y-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on"></script>
      </div>
      
      <h2>Why It Works This Way</h2>
      <p>As we can see in <b>image_1</b>, the stack memory contains both the <span class="coding-font">test1</span> and <span class="coding-font">changeLastName</span> methods. Each of these methods has its own local variables. However, the <span class="coding-font">person</span> variable in both methods points to the same memory address, which refers to the same object in the heap. As a result, when either method modifies any property of the <span class="coding-font">person</span> object, the changes are immediately visible to the other method as well, because both variables reference the same instance.</p>
      <figure>
        <picture>
          <img src="../images/ParameterPassing-test1.png" alt="test1">
        </picture>
        <figcaption><b>Image_1.-</b> Illustration for test1</figcaption>
      </figure>
      
      <p>In <span class="coding-font">test2</span>, the <span class="coding-font">newPerson</span> object variable is created as a clone of the original <span class="coding-font">person</span> object. This cloning process involves allocating a new object in the heap memory, which means <span class="coding-font">newPerson</span> refers to a separate memory location from <span class="coding-font">person</span>. Because these two variables now point to distinct objects, any modification made to the <span class="coding-font">newPerson</span> object will not impact the <span class="coding-font">person</span> object, and vice versa. Each variable maintains its own copy of the object's data. This separation contrasts with scenarios where multiple variables reference the same object (as in the previous example), leading to shared changes. The details of this process are illustrated in <b>image_2.</b></p>
      <figure>
        <picture>
          <img src="../images/ParameterPassing-test2.png" alt="test2">
        </picture>
        <figcaption><b>Image_2.-</b> Illustration for test2</figcaption>
      </figure>
      

      <h2>References</h2>
      <ul>
        <li><a href="https://en.wikipedia.org/wiki/Evaluation_strategy" target="_blank">Evaluation strategy</a></li>
        <li><a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-2.html" target="_blank">The Structure of the Java Virtual Machine</a></li>
      </ul>
      <div id="foot">
        <div id="footLeft">
          <p>Author: Aar√≥n Donoso Acedo<br>
          <a href="mailto:aaron.donoso82@gmail.com">Contact me</a></p>
        </div>
        <div id="footCenter">
          <p><a href="../index.html">Home</a></p>
        </div>
        <div id="footRight">
        </div>
      </div>
    </div>
  </body>
</html>
